name: Advanced C++ CI/CD Pipeline with Qt 6

on:
  push:
    branches: [ "**" ]       # Trigger on any branch push
  pull_request:
    branches: [ "**" ]       # Trigger on any branch PR

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-22.04
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install Qt 6 and dependencies
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y --no-install-recommends \
          qt6-base-dev \
          qt6-tools-dev \
          qt6-l10n-tools \
          qmake6 \
          cmake \
          g++ \
          build-essential \
          libgl1-mesa-dev \
          libglu1-mesa-dev \
          libfontconfig1 \
          libsqlite3-dev \
          cppcheck \
          valgrind \
          xvfb \
          bc
    
    - name: Verify Qt 6 installation
      run: |
        qmake6 --version
        which qmake6
    
    - name: Code Quality Analysis
      run: |
        echo "Running static analysis..."
        cppcheck --enable=all --xml --xml-version=2 . 2> cppcheck_report.xml || true
        echo "Static analysis completed"
    
    - name: Security Scan
      run: |
        echo "Running security analysis..."
        grep -r -i "password\|secret\|key" --include="*.cpp" --include="*.h" . || echo "No obvious credential issues found"
        echo "Security scan completed"
    
    - name: Build project with qmake6
      run: |
        qmake6 Embedded.pro
        make -j$(nproc)
    
    - name: Run Comprehensive Tests
      run: |
        mkdir -p test_results
        
        echo "Building and running Unit Tests..."
        if [ -d "./Unit-tests_tests" ]; then
          cd Unit-tests_tests
          if [ -f "Unit-tests_tests.pro" ]; then
            qmake6 Unit-tests_tests.pro
            make -j$(nproc)
            if [ -f "./Unit-tests_tests" ]; then
              xvfb-run -a ./Unit-tests_tests -xml -o ../test_results/unit_tests.xml || exit 1
            else
              echo "Unit test executable not found"
              exit 1
            fi
          else
            echo "Unit-tests_tests.pro not found"
            exit 1
          fi
          cd ..
        else
          echo "Unit-tests_tests directory not found"
          exit 1
        fi
        
        echo "Building and running Integration Tests..."
        if [ -d "./Integration_Test" ]; then
          cd Integration_Test
          if [ -f "Integration_Test.pro" ]; then
            qmake6 Integration_Test.pro
            make -j$(nproc)
            if [ -f "./Integration_Test" ]; then
              xvfb-run -a ./Integration_Test -xml -o ../test_results/integration_tests.xml || exit 1
            else
              echo "Integration test executable not found"
              exit 1
            fi
          else
            echo "Integration_Test.pro not found"
            exit 1
          fi
          cd ..
        else
          echo "Integration_Test directory not found"
          exit 1
        fi
    
    - name: Performance Benchmarking
      run: |
        echo "Running performance tests..."
        if [ -f ./Embedded ]; then
          echo "Measuring application performance..."
          
          # Use high-precision timing with millisecond resolution from start
          echo "=== Performance Metrics ===" > performance_summary.txt
          
          # Method 1: Using time command with millisecond precision
          echo "Starting precise timing measurement..."
          START_TIME=$(date +%s%3N)  # milliseconds since epoch
          
          # Run the application and capture both timing and memory info
          timeout 30s bash -c '
            exec 3>&1 4>&2
            TIMEFORMAT="%3R %3U %3S"
            { time ./Embedded --version >/dev/null 2>&4; } 2>&1 >&3 | {
              read REAL_TIME USER_TIME SYS_TIME
              USER_TIME_MS=$(echo "scale=2; $USER_TIME * 1000" | bc 2>/dev/null || echo "0")
              SYS_TIME_MS=$(echo "scale=2; $SYS_TIME * 1000" | bc 2>/dev/null || echo "0")
              REAL_TIME_MS=$(echo "scale=2; $REAL_TIME * 1000" | bc 2>/dev/null || echo "0")
              echo "TIMING_DATA:USER:$USER_TIME_MS:SYSTEM:$SYS_TIME_MS:REAL:$REAL_TIME_MS"
            }
          ' 2>&1 | tee timing_output.txt || echo "Timing completed with potential timeout"
          
          END_TIME=$(date +%s%3N)  # milliseconds since epoch
          WALL_CLOCK_MS=$((END_TIME - START_TIME))
          
          # Extract timing data from our custom output
          if grep -q "TIMING_DATA:" timing_output.txt; then
            TIMING_LINE=$(grep "TIMING_DATA:" timing_output.txt | tail -1)
            USER_TIME_MS=$(echo "$TIMING_LINE" | sed -n 's/.*USER:\([^:]*\):.*/\1/p')
            SYS_TIME_MS=$(echo "$TIMING_LINE" | sed -n 's/.*SYSTEM:\([^:]*\):.*/\1/p')
            REAL_TIME_MS=$(echo "$TIMING_LINE" | sed -n 's/.*REAL:\([^:]*\):.*/\1/p')
            
            echo "User time: ${USER_TIME_MS} ms" >> performance_summary.txt
            echo "System time: ${SYS_TIME_MS} ms" >> performance_summary.txt
            echo "Real time: ${REAL_TIME_MS} ms" >> performance_summary.txt
          else
            echo "User time: N/A ms" >> performance_summary.txt
            echo "System time: N/A ms" >> performance_summary.txt
            echo "Real time: N/A ms" >> performance_summary.txt
          fi
          
          echo "Wall clock time: ${WALL_CLOCK_MS} ms" >> performance_summary.txt
          
          # Get memory usage with /usr/bin/time
          echo "Measuring memory usage..."
          timeout 30s /usr/bin/time -v ./Embedded --version 2>&1 | tee memory_report.txt || echo "Memory measurement completed"
          
          # Extract memory information
          MAX_RSS=$(grep "Maximum resident set size" memory_report.txt | awk '{print $6}' 2>/dev/null || echo "N/A")
          if [ "$MAX_RSS" != "N/A" ]; then
            echo "Maximum resident set size: ${MAX_RSS} KB" >> performance_summary.txt
          else
            echo "Maximum resident set size: N/A KB" >> performance_summary.txt
          fi
          
          # Additional memory metrics
          AVG_RSS=$(grep "Average resident set size" memory_report.txt | awk '{print $6}' 2>/dev/null || echo "N/A")
          if [ "$AVG_RSS" != "N/A" ]; then
            echo "Average resident set size: ${AVG_RSS} KB" >> performance_summary.txt
          fi
          
          PAGE_FAULTS=$(grep "Page faults" memory_report.txt | awk '{print $3}' 2>/dev/null || echo "N/A")
          if [ "$PAGE_FAULTS" != "N/A" ]; then
            echo "Page faults: ${PAGE_FAULTS}" >> performance_summary.txt
          fi
          
          echo "" >> performance_summary.txt
          echo "=== Performance Summary ===" >> performance_summary.txt
          if [ "$USER_TIME_MS" != "N/A" ] && [ "$SYS_TIME_MS" != "N/A" ]; then
            TOTAL_CPU_MS=$(echo "scale=2; $USER_TIME_MS + $SYS_TIME_MS" | bc 2>/dev/null || echo "N/A")
            echo "Total CPU time: ${TOTAL_CPU_MS} ms" >> performance_summary.txt
            
            if [ "$REAL_TIME_MS" != "N/A" ] && [ "$REAL_TIME_MS" != "0" ]; then
              CPU_USAGE=$(echo "scale=2; ($TOTAL_CPU_MS / $REAL_TIME_MS) * 100" | bc 2>/dev/null || echo "N/A")
              echo "CPU usage: ${CPU_USAGE}%" >> performance_summary.txt
            fi
          fi
          
          echo "" >> performance_summary.txt
          echo "=== Measurement Details ===" >> performance_summary.txt
          echo "Timing method: bash built-in time + date milliseconds" >> performance_summary.txt
          echo "Memory method: /usr/bin/time -v" >> performance_summary.txt
          echo "Timeout: 30 seconds" >> performance_summary.txt
          
          cat performance_summary.txt 2>/dev/null || echo "Performance summary created"
          
          # Clean up temporary files
          rm -f timing_output.txt memory_report.txt 2>/dev/null || true
        fi
    
    - name: Prepare Deployment Package
      run: |
        echo "Preparing deployment package..."
        mkdir -p deployment_package
        
        if [ -f ./Embedded ]; then
          cp ./Embedded deployment_package/
          echo "Executable copied to deployment package"
        fi
        
        find . -name "*.conf" -o -name "*.ini" -o -name "*.db" | xargs -I {} cp {} deployment_package/ 2>/dev/null || true
        
        echo "Build Date: $(date)" > deployment_package/build_info.txt
        echo "Commit Hash: $GITHUB_SHA" >> deployment_package/build_info.txt
        echo "Branch: $GITHUB_REF_NAME" >> deployment_package/build_info.txt
        
        ls -la deployment_package/
    
    - name: Upload Comprehensive Artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: complete-build-artifacts-${{ github.run_number }}
        path: |
          Embedded
          deployment_package/
          test_results/
          performance_*.txt
          cppcheck_report.xml
          *.o
          Makefile
        retention-days: 30

  deploy:
    needs: build
    runs-on: ubuntu-22.04
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: complete-build-artifacts-${{ github.run_number }}
        path: ./artifacts

    - name: Prepare Deployment Directory
      run: |
        echo "Preparing deployment directory..."
        mkdir -p deployment
        cp artifacts/Embedded deployment/ 2>/dev/null || true
        cp -r artifacts/deployment_package/* deployment/ 2>/dev/null || true
        chmod +x deployment/Embedded || true
        echo "Deployment Information" > deployment/DEPLOYMENT_INFO.txt
        echo "Build Date: $(date)" >> deployment/DEPLOYMENT_INFO.txt
        echo "Version: v${{ github.run_number }}" >> deployment/DEPLOYMENT_INFO.txt
        echo "Commit: ${{ github.sha }}" >> deployment/DEPLOYMENT_INFO.txt
        ls -la deployment/

    - name: Create Release Archive (.zip)
      run: |
        cd deployment
        zip -r ../tic-tac-toe-v${{ github.run_number }}.zip ./*
        cd ..
        echo "Release archive created: tic-tac-toe-v${{ github.run_number }}.zip"

    - name: Package Test Results
      run: |
        echo "Zipping test results..."
        zip -r test_results_package.zip artifacts/test_results/
        echo "Test results zipped into test_results_package.zip"

    - name: Create GitHub Release Tag
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a v${{ github.run_number }} -m "Automated release v${{ github.run_number }}"
        git push origin v${{ github.run_number }}

    - name: Deploy Application
      run: |
        echo "Deploying Tic Tac Toe application..."
        DEPLOY_DIR="/tmp/tic-tac-toe-production"
        mkdir -p $DEPLOY_DIR
        cp -r deployment/* $DEPLOY_DIR/
        echo "Application deployed successfully to $DEPLOY_DIR"

    - name: Verify Deployment
      run: |
        if [ -f /tmp/tic-tac-toe-production/Embedded ]; then
          echo "Deployment verification: SUCCESS"
          /tmp/tic-tac-toe-production/Embedded --version || echo "Version check completed"
        else
          echo "Deployment verification: FAILED"
          exit 1
        fi

    - name: Upload Release Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: release-package-v${{ github.run_number }}
        path: |
          tic-tac-toe-v${{ github.run_number }}.zip
          deployment/
          test_results_package.zip
        retention-days: 30

    - name: Upload to GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ github.run_number }}
        name: Release v${{ github.run_number }}
        body: |
          Automated release for build ${{ github.run_number }}.
          See attached files for the game executable, deployment package, and test results.
        files: |
          tic-tac-toe-v${{ github.run_number }}.zip
          deployment/*
          test_results_package.zip
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}